Solve the following leetcode problems, both using the suggested data structures and without.
Are they an improvement?

Consider the following criteria:
* Does is make your code shorter or easier to understand?
* Is it asymptotically more efficient? (For example, does it change a O(n^2) algorithm to a O(n) algorithm)

Solve as many of the following problems as you can in 6 hours of working outside of class.
Do not search for or use others solutions posted on the internet, especially forums, github, Youtube, stackoverflow, or AI chat.

## Java Review


## Number Complements
(Acceptance Percentage 70.3%)

Flip all the bits of a number to get its complement, with the same bit width as the leading 1.

The decimal number 5 (in binary 101) -> has a complement of 2 (in binary 010)

However, the reverse is slightly different.

The decimal number 2 (in binary 10) -> has a complement of 1 (in binary 01)
(i.e. do not pad leading zeros with 1's)

https://leetcode.com/problems/number-complement/description/
## Converting Roman Numerals to Int
(Acceptance Percentage 62.8%)

https://leetcode.com/problems/roman-to-integer/description/

If you complete this problem with $O(nd)$ time and $O(d)$ space, where `n` is the number of input Roman numeral digits and `d` is the number of different kinds of Roman digits, try optimizing your solution to use $O(n)$ time only, still with $O(d)$ space allowed.
## Choose Your Own
From the list of problems sorted by decreasing acceptance rate (increasing difficulty) choose two problems that you think will take you one hour each. Use your experience with the first TPS homework and the above two problems to calibrate your problem choice.

